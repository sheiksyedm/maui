# PR Review: #33918 - Modal TabbedPage with NavigationPage tabs leaks on Android

**Date:** 2026-02-06 | **Issue:** [#33918](https://github.com/dotnet/maui/issues/33918) | **PR:** None (fixing issue)

## ‚è≥ Status: IN PROGRESS

| Phase | Status |
|-------|--------|
| üìã Pre-Flight | ‚úÖ COMPLETE |
| üß™ Tests | ‚úÖ COMPLETE |
| üö¶ Gate | ‚úÖ PASSED |
| üîß Fix | ‚ñ∂Ô∏è IN PROGRESS |
| üìã Report | ‚è≥ PENDING |

---

<details>
<summary><strong>üìã Issue Summary</strong></summary>

**Title:** [Android] Modal TabbedPage whose tabs are NavigationPage(ContentPage) is retained after PopModalAsync()

**Description:**
On Android, a modal navigation flow that pushes a TabbedPage (via INavigation.PushModalAsync) leaks after it is popped when each tab is wrapped in its own NavigationPage. After PopModalAsync(), forcing a full GC does not reclaim the modal TabbedPage or its tab pages.

This leads to unbounded memory growth in apps that repeatedly open/close modal tabbed workflows.

**Steps to Reproduce:**
1. Deploy/run the reproduction app on Android
2. Ensure "Wrap tabs in NavigationPage" is ON
3. Tap "Run repro N times"
4. Observe that the "Alive" count does not return to 0 after each pop + GC
5. The alive counts increase as the loop repeats

**Expected Behavior:**
After `await Navigation.PopModalAsync()` completes and there are no remaining app references, the popped modal TabbedPage and its child pages should become eligible for collection and be reclaimed by a forced full GC. The tracked objects' "Alive" count should return to 0.

**Actual Behavior:**
On Android, after each modal pop and forced full GC:
- The popped modal TabbedPage remains alive
- The tab children remain alive (the per-tab NavigationPage wrappers)
- The inner ContentPage inside each NavigationPage remains alive
- The "Alive" counts increase as the loop repeats

**Platforms Affected:**
- [x] Android
- [ ] iOS
- [ ] Windows
- [ ] MacCatalyst

**Regression:** Yes - regressed in 10.0.0 (worked in 9.0.120)

**Reproduction Repository:** https://github.com/brunck/reproductions/tree/master/MauiTabbedModalLeakRepro

**Version:** 10.0.31

**Verified by:** TamilarasanSF4853 - Reproduced in .NET 10 on Android, NOT in .NET 9

</details>

<details>
<summary><strong>üìÅ Files Changed</strong></summary>

| File | Type | Changes |
|------|------|---------|
| `src/Controls/tests/TestCases.HostApp/Issues/Issue33918.cs` | Test (HostApp) | New file |
| `src/Controls/tests/TestCases.Shared.Tests/Tests/Issues/Issue33918.cs` | Test (NUnit) | New file |

</details>

<details>
<summary><strong>üí¨ Issue Discussion Summary</strong></summary>

**Key Comments:**
- TamilarasanSF4853 validated this is a regression in .NET 10
- Issue verified with MAUI versions 9.0.120, 10.0.0, and 10.0.31
- NOT reproduced in .NET 9 MAUI version 9.0.120
- Video evidence provided showing the leak

**Reproduction Details:**
- Uses standard MAUI Navigation (no Shell)
- Common pattern in apps with modal tabbed workflows
- GC.Collect() + GC.WaitForPendingFinalizers() + GC.Collect() does NOT reclaim

</details>

<details>
<summary><strong>üß™ Tests</strong></summary>

**Status**: ‚úÖ COMPLETE

- [x] Tests created following naming convention (`Issue33918`)
- [x] Tests verified to compile
- [x] Tests verified to FAIL (reproduce the bug)

**Test Files:**
- HostApp: `src/Controls/tests/TestCases.HostApp/Issues/Issue33918.cs`
- NUnit: `src/Controls/tests/TestCases.Shared.Tests/Tests/Issues/Issue33918.cs`

**Test Type:** UI Tests (memory leak test)

**Test Category:** TabbedPage

**Test Approach:**
- Creates a modal TabbedPage with NavigationPage-wrapped tabs
- Pushes it modally
- Switches to a different tab
- Pops the modal
- Forces GC using `GarbageCollectionHelper.WaitForGC()`
- Verifies all WeakReferences are collected (no leak)

</details>

<details>
<summary><strong>üö¶ Gate - Test Verification</strong></summary>

**Status**: ‚úÖ PASSED

- [x] Tests FAIL without fix (bug reproduced)

**Platform for testing:** Android (only affected platform)

**Result:** PASSED ‚úÖ

**Test Execution Details:**
- Test: `ModalTabbedPageWithNavigationPageTabsDoesNotLeak`
- Result: FAILED as expected
- Error: Memory leak detected - Status shows "Forcing GC..." instead of "Success"
- This confirms the test correctly reproduces the bug

</details>

<details>
<summary><strong>üîß Fix Candidates</strong></summary>

**Status**: ‚è≥ PENDING

| # | Source | Approach | Test Result | Files Changed | Notes |
|---|--------|----------|-------------|---------------|-------|
| 1 | try-fix #1 | Clean up TabLayoutMediator and Adapter on modal dismissal + disconnect handlers in TeardownPage | ‚ùå FAIL | TabbedPageManager.cs | Attempted to fix by: (1) Detaching TabLayoutMediator in SetElement(), (2) Disposing FragmentStateAdapter properly, (3) Disconnecting handlers for NavigationPage children and parent pages in TeardownPage(). Failed after 3 iterations - GC still cannot collect references. Root cause appears deeper: fragments may not be destroyed properly when modal is popped, FragmentManager may hold strong references, or SetElement() may not be called during modal pop. |
| 2 | try-fix #2 | Fragment lifecycle cleanup: Always disconnect handlers in FragmentContainer.OnDestroy(), add DisconnectAllKeys() to adapter, call before TeardownPage | ‚ùå FAIL | FragmentContainer.cs, MultiPageFragmentStateAdapter.cs, TabbedPageManager.cs | Different approach from #1: focused on fragment lifecycle cleanup rather than TabLayoutMediator. Removed Context.IsDestroyed() check in FragmentContainer.OnDestroy() and added explicit key disconnection. Failed after 3 iterations. Root cause is deeper - possibly in modal navigation handling or StackNavigationManager. |
| 3 | try-fix #3 | Break FragmentStateAdapter strong references: Dispose clears AdapterItemKey subscriptions + clears adapter reference to MultiPage | ‚ùå FAIL | MultiPageFragmentStateAdapter.cs, TabbedPageManager.cs | Test still reports leak (Status stuck at "Forcing GC..."). Suggests retention is not primarily from adapter-managed references; likely fragment/view/root manager still roots the modal TabbedPage stack after pop. |
| 4 | try-fix #4 | Remove FragmentContainer instances from FragmentManager on TabbedPage teardown | ‚ùå FAIL | MultiPageFragmentStateAdapter.cs, TabbedPageManager.cs | Explicitly removed adapter-created FragmentContainer fragments tied to the tabbed page during teardown; test still reported leak ("Forcing GC..."). |
| 5 | try-fix #5 | Dual Disconnect Strategy: Manual Disconnect() on Adapter + AdapterItemKey, and unconditional DisconnectHandler in FragmentContainer.OnDestroy | ‚ùå FAIL | FragmentContainer.cs, MultiPageFragmentStateAdapter.cs, TabbedPageManager.cs, AdapterItemKey.cs | Identified specific leak chain (Activity Lifecycle -> Adapter -> Keys -> AdapterItemKey -> Page). Implemented manual disconnection breaking links at all points. Test still reports leak, suggesting potential additional leaks (e.g. NavigationPageRenderer) or test timing issues. |
| 6 | try-fix #6 | Unregister OnBackPressedDispatcher callback on modal dialog stop/dispose | ‚ùå FAIL | ModalNavigationManager.Android.cs | Test failed before leak assertion with `NullReferenceException` at `App.FindElement("StatusLabel").GetText()` (Issue33918.cs:30), so leak status could not be validated. |

**Exhausted:** No
**Selected Fix:** [PENDING]

</details>

---

**Next Step:** Verify tests compile and reproduce the bug (Phase 2: Tests), then Gate verification.
